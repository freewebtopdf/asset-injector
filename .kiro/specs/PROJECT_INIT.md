# Prompt for AI Assistant: Asset Injector Microservice

**Role:** Senior Go Backend Engineer & Software Architect
**Objective:** Design and implement a high-performance, mission-critical microservice called **"Asset Injector"**.
**Context:** This service acts as a centralized rules engine for a high-throughput "Web-to-PDF" pipeline. It receives a target URL and returns custom CSS/JavaScript payloads to "clean up" web pages (e.g., hiding cookie banners) before they are rendered into PDFs. Reliability and low latency are paramount.

## Technical Specifications

### 1. Technology Stack

* **Language:** Go (Golang) 1.23+
* **Web Framework:** Fiber v2 (for high-performance routing and middleware).
* **Logging:** Zerolog (Structured JSON logging).
* **Documentation:** Swagger/OpenAPI 2.0 (Code-first via `swaggo/swag`).
* **Configuration:** `godotenv` for local `.env` support. strict struct-based parsing for production.

### 2. Architecture & Project Structure & Patterns

* **Layout:** Strict adherence to the **Standard Go Project Layout**:
  * `cmd/injector/` (Main entry point)
  * `internal/api/` (HTTP Handlers)
  * `internal/config/` (Configuration loading & validation)
  * `internal/core/` (Domain logic: Matcher, Rule models)
  * `internal/store/` (In-memory storage & persistence)
* **Design Principles:**
  * **Hexagonal/Clean Architecture:** The core logic (Matcher) must NOT depend on Fiber or HTTP.
  * **Interface Segregation:** API handlers must depend on a `RuleRepository` interface, not concrete structs, to facilitate future mocking or database swaps.
  * **Dependency Injection:** explicit wiring in `main.go`. No global variables.
* **Data Store:**
  * **In-Memory:** Store rules in a thread-safe slice/map for $O(1)$ or $O(N)$ access.
  * **Persistence:** Use a **Single JSON File** (`snapshot.json`) with **Atomic Writes** (Write Temp $\to$ Sync $\to$ Rename).
  * **Dual Indexing:** Use a **Map** for O(1) ID lookups (CRUD) and a **Slice** for iteration (Resolution). Keep them in sync.
  * **Startup Resilience:** Auto-create data directories; treat missing snapshot as "fresh install" (log warning, do not crash).

### 3. Core Logic: The Matching Engine (Crucial)

The service must match an input URL against a list of defined rules and return the *single best match*.

* **Matching Strategy:** Implement a "Specificity Wins" algorithm. Calculate a **Score** for every match.
  * **Score Formula:** `BasePriority + PatternLength`
  * **Manual Override:** If the rule's `Priority` field is set (not nil), use that value directly and skip the formula.
* **Priority Tiers (Base Priority):**
    1. **Exact Match** (Base: 1000): The URL matches the pattern exactly.
    2. **Regex Match** (Base: 500): The URL matches a regular expression.
    3. **Wildcard/Glob** (Base: 100): The URL matches a glob pattern (e.g., `*.example.com/blog/*`).
* **Tie-Breaker:** If two rules of the same type match, the **Longer Pattern** wins (it is assumed to be more specific).
  * *Example:* `example.com/blog/shared/*` (Longer) beats `example.com/blog/*` (Shorter).
* **Performance Requirement:**
  * **Locking Strategy:** The `Resolve` method (Hot Path) must use **`RLock()` (Read Lock)** to allow concurrent reads. Only mutations use `Lock()`.
  * **Regex Compilation:** **Do NOT compile regexes during the resolution request.** Regex rules must be pre-compiled and stored in the `Matcher` struct when rules are added/loaded.
  * **Wildcard Logic:** Use a glob matching logic where `*` matches across path separators (e.g., `example.com/*` matches `example.com/foo/bar`).
  * **Context Awareness:** Ensure matching methods accept `context.Context` for potential timeout/cancellation handling.
  * **Zero-Allocation Hot Path:** Optimize the `Resolve` method to avoid unnecessary memory allocations.

### 4. Data Model (The "Rule" Struct)

**Please use this specific structure for the Rule entity:**

```go
type Rule struct {
    ID        string `json:"id"` // UUID, generated by server if empty
    Type      string `json:"type"` // "exact", "regex", "wildcard"
    Pattern   string `json:"pattern"`
    CSS       string `json:"css"`
    JS        string `json:"js"`
    Priority  *int   `json:"priority,omitempty"` // Manual override
    CreatedAt time.Time `json:"created_at"`
}
```

### 5. API & Transport Layer

* **Security:**
  * Configure Fiber with a strict **Body Limit** (e.g., 1MB) to prevent DoS attacks via massive payloads.
  * **Enable CORS** (restrict to allowed origins in config).
  * **Enable Security Headers** (Fiber Helmet middleware) for HSTS and XSS protection.
* **Sanitization:** Automatically **Trim Space** from all input URLs and Patterns to prevent "invisible whitespace" bugs.
* **Status Codes:** Use strict semantic codes (e.g., `422` for validation errors, `201` for creation).
* **Endpoints:**
  * `GET /health`: Liveness probe. Returns `200` OK.
  * `GET /metrics`: Returns internal stats (Cache Hit/Miss counts, Rule count, Uptime) in JSON format.
  * `POST /v1/resolve`:
    * Input: `{ "url": "https://example.com/article" }`
    * Output: `{ "css": "...", "js": "...", "rule_id": "123", "cache_hit": true }` (Returns the single highest-scoring match).
  * `GET /v1/rules`: List all active rules.
  * `POST /v1/rules`: Create or Update a rule. **MUST generate ID if missing. MUST validate regex compilation. MUST limit CSS/JS size (max 100KB).**
  * `DELETE /v1/rules/:id`: Remove a rule.
* **Middleware Pipeline (Order Matters):**
  1. **RequestID:** Generate UUID for every request.
  2. **Logger:** Log RequestID, Method, Path, Latency, Status.
  3. **Recover:** Catch panics, log stack trace, return 500 (prevent crash).
  4. **Security (Helmet):** XSS/HSTS headers.
  5. **CORS:** Restrict origins.
  6. **BodyLimit:** Max 1MB payload.
* **Error Handling:** Centralized error handler that returns strict JSON: `{"status": "error", "code": "INVALID_INPUT", "message": "..."}`.
  7. **Timeout:** Enforce a hard timeout (e.g., 2s) on API context.
* **Error Handling:**
  * Define a custom `AppError` struct in `internal/core` that maps Domain Errors to HTTP Status Codes.
  * Implement a Centralized Error Handler in Fiber that unwrap `AppError` and returns strict JSON: `{"status": "error", "code": "INVALID_INPUT", "message": "..."}`.

### 6. Production Readiness

* **Memoization:** Implement a **Bounded LRU Cache** (configurable size, default 10k items) for /v1/resolve to prevent memory leaks while caching results.
  * **Observability:** Track cache hits/misses using atomic counters and expose via `/metrics`.
* **Graceful Shutdown:** Implement `os.Signal` handling (SIGINT/SIGTERM). On shutdown, the server must:
  * Stop accepting new connections.
  * **Force a final save** of `snapshot.json` to disk to ensure data integrity.
* **Concurrency:** All data access must be thread-safe (`sync.RWMutex`).
* **Testing:**
  * Provide comprehensive Table-Driven Unit Tests for internal/matcher. Include edge cases like empty URLs, no matches, priority tie-breaking, **bad regex inputs**, and **whitespace handling**.
  * **Mock-based Tests** for API handlers (mocking the Store interface).
* **Configuration:**
  * **Fail-Fast:** Crash on startup if PORT/Config is invalid.
  * **Sanitization:** Automatically strings.TrimSpace inputs.
* **DevOps:**
  * **Dockerfile:** Multi-stage build (Alpine Builder -> Scratch Runner).
  * **Makefile:**
    * `build`, `run`, `docker-build`
    * `test`: Run with race detection: `go test -race ./...`.
    * `lint`: Run `golangci-lint run` to check for code quality issues.
    * `swag`: swag init -g cmd/injector/main.go --output docs

## Deliverables

Please provide the code and explanation for the following:

1. **Project Directory Tree:** Visual structure of the files.
2. **`internal/core/domain.go`:** Rule structs, AppError struct, and RuleRepository interface.
2. **`internal/core/matcher.go`:** The Go code implementing the matching logic with **pre-compiled regex storage** and Context support.
3. **`internal/core/matcher_test.go`:** Table-driven tests covering the logic.
4. **`internal/store/store.go`:** Thread-safe store with Atomic Snapshot and Dual Indexing (Map + Slice).
5. **`internal/api/handlers.go`:** Fiber handlers with **full Swagger/OpenAPI annotations**, validation and LRU caching integration.
6. **`internal/config/config.go`:** Configuration loading with **Fail-Fast Validation** (ensure ports are valid, limits are positive).
7. **`cmd/injector/main.go`:** Dependency injection, Middleware(including Timeout & Error Handler) setup, Wiring everything together & Graceful Shutdown logic.
